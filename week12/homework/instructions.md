# Homework 8: Monads

**Due**: Wednesday, April 9 at 11:59 p.m.

## Exercise 1

Implement the functions with the provided type signatures. Write each function
twice, once with `do` notation and once using `>>=` directly. Try to figure
out what each of these should be first from just the types. If you're stuck,
we provided an explanation of the expected behavior at the bottom of this
page.

Note: as usual, you should NOT add any extra imports for this problem,
though you might get an hlint suggestion to do so.

## Exercise 2

In this exercise, we will examine a new context where monads are useful.
Suppose we want to maintain a log, perhaps for debugging purposes, as we
compute some result. We record both the log (of type `String`) and the final
result (of any type `a`) in the custom data type

```
data Logger a = Logger String a
```

This is fine when we have just one computation, for example in the
definition of `square`, but if we want to _combine_ multiple computations that
might have logging statements, the code becomes clunkier than we would like.

For example, without the `Logger`, if we want to square a number twice, we
would be able to simply do `square . square`, but with the `Logger`, we instead
need something along these lines:

```
squareTwice :: Double -> Logger Double
squareTwice n =
  let Logger log1 n2 = square n
   in let Logger log2 n4 = square n2
    in Logger (log1 ++ "\n" ++ log2) n4
```

That is, we need to manually give a name to and combine the logs from each
computation. (Note that we can make this syntax _slightly_ nicer by combining
the `let`s, as shown in `Exercises.hs`, but the overall clunkiness persists.)

### Part (a)

This is precisely where
monads can be useful: for threading (a model of) a side effect through the code
neatly, using special syntax (`do` notation) that allows us to view the program
as a sequence of effectful actions, even though the underlying code is still
pure and functional. In this case, the side effect is writing logs. Instead of
manually combining these computations like we did in `squareTwice` every time,
we can abstract away these details via a `Monad` instance for `Logger`.

In particular, `return a` should return a `Logger` with result `a` and an empty
log. And `(Logger log a) >>= k` should return a `Logger` whose result is the
result obtained from applying `k` to `a`, and whose log is the concatenation of
the original log and the log generated by `k`, separated by a newline.

Implement the `Monad` instance according to this specification. Then, take a
look at our new version of `squareTwice`, named `squareTwiceM`.

### Part (b)

Suppose we have a more complex computation, where we use the Pythagorean
theorem to compute a hypotenuse. Implement `pythagoreanM` to do the same thing
as `pythagorean`, but take advantage of the `Monad` instance (and `do`
notation) to abstract away the details of accumulating the log.

### Part (c)

We might wonder why we don't just use `IO` to print debugging statements. One
reason is that the `Logger` monad, and its generalization, the `Writer` monad
(which works on accumulated values other than `String`s), allow more
fine-grained control over what to do with the log.

For example, we might write a function that takes in a boolean flag representing
verbosity and only prints the log when the flag is set to true. Let's try this —

First, re-implement the `Monad` library function `when`, which supports
conditional execution of a monadic computation — when the boolean flag is
`True`, then we return that computation; otherwise, we return `()` (unit)
as interpreted in that monad. (You may find the standard library function
`const` useful here.)

Next, using `when`, fill in the unimplemented line of `printLogger` to satisfy
the behavior described above. That is, we should have

```
> printLogger True (pythagoreanM 3 4)
squared 3.0
squared 4.0
added 9.0 and 16.0
took the square root of 25.0
5.0
> printLogger False (pythagoreanM 3 4)
5.0
```

## Grading

Exercises 1 and 2b will be both auto- and manually graded, and Exercises 2a and 2c will be autograded. There will also be the usual points for style.

## Explanation for Exercise 1
`fish` is what Haskell users call the Kleisli composition operator, because the
symbol used for it in the standard library is `>=>`. (As usual, please do not
look up the source code definition of `>=>` when reimplementing it here.) A
Kleisli arrow is of the form `a -> m b` for some monad `m`. In general, it is
very important to be able to compose functions, but this becomes more
complicated with monads: if `f` has type `a -> m b` and `g` has type `b -> m c`
then we cannot directly compose them with `.`, because `g` is expecting a value
of type `b`, not `m b`. We fix this by defining a composition operator
specifically for use with Kleisli arrows.

`join` "flattens" a monadic value. If you end up mid-program with a value like
`Just (Just x)`, that should really be conceptually equivalent to `Just x`.
Both represent a successful computation resulting in `x` in our model of
potentially-failing computations; it does not mean anything in this model
to have "doubly succeeded". Similarly, `Just Nothing` is conceptually
equivalent to `Nothing`; a computation that "successfully" results in a failure
is just a failure.
`join` allows us to simplify monadic values in this way, for any monad, by
"flattening" multiple "layers" of the monad down into one "layer".